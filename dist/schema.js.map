{"version":3,"sources":["utils.js","constructor.js","compile.js","validate.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"schema.js","sourcesContent":["/**\n * Verifica si el objeto pasado es un objeto literal.\n * @param {Object} obj Objeto a verificar\n * @returns {Boolean}\n */\nconst objLiteral = function (obj) {\n  return Object.prototype.toString.call(obj).toLowerCase() === '[object object]'\n};\n\n/**\n * Lista de tipos de formato de variables\n */\nconst typesAccepted = ['string', 'number', 'boolean', 'array', 'object'];\n\n/**\n * Obtiene el tipo del valor pasado.\n * @param {Object|String} value El string y objecto que contiene el valor del objeto\n * @return {String}\n */\nconst getType = function (value) {\n  let retorno;\n  if (Array.isArray(value)) {\n    retorno = 'array';\n  } else {\n    if (objLiteral(value)) {\n      if (value.hasOwnProperty('type')) {\n        retorno = Array.isArray(value.type) ? 'mixed' : value.type\n      } else {\n        retorno = 'object';\n      }\n    } else {\n      const typeOfVal = typeof value;\n      if (typeOfVal === 'string') {\n        retorno = (typesAccepted.indexOf(value) === -1) ? typeOfVal : value;\n      } else {\n        retorno = typeOfVal\n      }\n\n    }\n  }\n  return retorno;\n};\n\n/**\n * Registra incidentes dentro de un objeto, para que sirva de log.\n * @param {Array|Object} target Lista y objeto destino.\n * @param {String} propName Nombre de la propiedad a crear dentro del objeto.\n * @param {Object} data Objeto que contendr치 informaci칩n de la propiedad faltante.\n * @returns {Boolean} Registro exitoso: true. Intento de registro duplicado: false\n */\nconst reg = function (target, propName, data) {\n  let retorno = false;\n  if (Array.isArray(target)) {\n    target.push(data);\n    retorno = true;\n  } else {\n    if (!target.hasOwnProperty(propName)) {\n      target[propName] = data;\n      retorno = true;\n    }\n  }\n  return retorno;\n};\n\n/**\n * Realiza un merge de los registros obtenidos de por el tratado de un subschema.\n * @param {Object} objTarget Objeto destino en donde se realizar치 el merge de las propiedades.\n * @param {Object} schema Objeto que contiene los registros (missings, errors, different)\n * @param {String} parentProp Nombre de la propiedad padre de los registros\n * @returns {Object}\n */\nconst mergeProps = function (objTarget, schema, parentProp) {\n  // ERRORS\n  const itemReg = schema.errors;\n  if (itemReg.length) objTarget.errors = objTarget.errors.concat(itemReg);\n  \n  // MISSINGS\n  let missing;\n  ['required', 'optional'].forEach(function (item) {\n    missing = schema.missings[item];\n    if (missing.length) objTarget.missings[item] = objTarget.missings[item].concat(missing);\n  });\n  \n  // DIFFERENT AND COMPILED\n  let currentSchema;\n  ['different', 'compiled'].forEach(function (objName) {\n    currentSchema = schema[objName];\n    if (Object.keys(currentSchema).length) {\n      if (!objTarget[objName].hasOwnProperty(parentProp)) objTarget[objName][parentProp] = {};\n      objTarget[objName][parentProp] = currentSchema;\n    };\n  });\n};","/**\n * Constructor del schema.\n * @constructor\n * @param {Object} obj Configuraciones iniciales del schema\n */\nfunction Schema (obj) {\n  this.schema = Object.assign({}, obj);\n  this.missings = {\n    required: [],\n    optional: []\n  };\n  this.different = {};\n  this.errors = [];\n  this.compiled = {};\n};","/**\n * Se obtiene el objeto compilado, el que a pasado por el schema\n * con las variables por defecto fusionadas.\n */\nSchema.prototype.compile = function () {\n  return this.missings.required.length ? false : this.compiled;\n};","/**\n * Valida si un objeto cumple con el schema designado.\n * @param {Object} response Objeto que comunmente se obtiene de un 'response' en una solicitud ajax\n * @returns {Boolean} Indica si el objeto pasado es v치lido o no con el schema.\n */\nSchema.prototype.validate = function (response) {\n  const schema = this.schema,\n        _this = this;\n  let retorno = true; // by default, is valid :)\n\n  Object.keys(schema).forEach(function (property) {\n    // Data form schema\n    const valPropSchema = schema[property];\n    const getTypeValSchema = getType(valPropSchema);\n\n    if (response.hasOwnProperty(property)) {\n      // Data from response\n      const valPropObj = response[property];\n      const getTypeValObj = getType(valPropObj);\n\n      switch (getTypeValSchema) {          \n        case 'string': // dont exists 'required', obiusly.\n          if (getTypeValObj !== 'string') {\n            reg(_this.different, property, {\n              current: getTypeValObj,\n              expected: 'string',\n              value: valPropObj\n            });\n          } else {\n            reg(_this.compiled, property, valPropObj)\n          }\n          break;\n\n        case 'array':\n          if (getTypeValSchema !== getTypeValObj) {\n            if (valPropSchema.required) retorno = false;\n            reg(_this.different, property, {\n              current: getTypeValObj,\n              expected: 'array',\n              value: valPropObj\n            });\n          } else {\n            reg(_this.compiled, property, valPropObj)\n          }\n          break;\n        \n        case 'object':\n          if (getTypeValObj === 'object') {\n            if (valPropSchema.hasOwnProperty('properties')) {\n              const propertiesSchema = new Schema(valPropSchema.properties);\n              if (!propertiesSchema.validate(valPropObj)) retorno = false;\n              mergeProps(_this, propertiesSchema, property);\n            } else {\n              reg(_this.compiled, property, valPropObj);\n            }\n          } else {\n            if (valPropSchema.required) {\n              retorno = false;\n              reg(_this.different, property,{\n                current: getTypeValObj,\n                expected: getTypeValSchema,\n                value: valPropObj\n              });\n            }\n          }\n          break;\n        \n        case 'mixed':\n          const typesList = valPropSchema.type;\n          const typesValid = typesList.filter(function (type) {\n            return type === getTypeValObj;\n          });\n          // no body match with any types items.\n          if (!typesValid.length && valPropSchema.required) { \n            retorno = false;\n            reg(_this.different, property, {\n              current: getTypeValObj,\n              expected: typesList,\n              value: valPropObj\n            });\n          } else {\n            reg(_this.compiled, property, valPropObj)\n          }\n          break;\n\n        default:\n          console.log('format type dont accepted: ' + getTypeValSchema);\n      }\n    } else {\n      let missing;\n      if (valPropSchema.required) {\n        retorno = false;\n        missing = 'required';\n      } else {\n        missing = 'optional';\n      }\n      reg(_this.missings[missing], null, property);\n      if (valPropSchema.default) _this.compiled[property] = valPropSchema.default;\n    }\n  });\n\n  // Returning\n  return retorno;\n};"]}