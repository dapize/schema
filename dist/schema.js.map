{"version":3,"sources":["utils.js","constructor.js","compile.js","validate.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"schema.js","sourcesContent":["/**\r\n * Utilidades varias\r\n * @namespace uSchema\r\n * @property {Array} typesAccepted Lista de tipos aceptados para ser procesados.\r\n */\r\nconst uSchema = {\r\n\r\n  /**\r\n   * Verifica si lo pasado es un objeto literal o no\r\n   * @memberof uSchema\r\n   * @param {Object} obj Objeto a ser verificado\r\n   * @returns {Boolean}\r\n   * @example\r\n   * uSchema.objLiteral({});\r\n   * => true\r\n   * @example\r\n   * uSchema.objLiteral('obj');\r\n   * => false\r\n   */\r\n  objLiteral: function (obj) {\r\n    return Object.prototype.toString.call(obj).toLowerCase() === '[object object]'\r\n  },\r\n\r\n  typesAccepted: ['string', 'number', 'boolean', 'array', 'object'],\r\n\r\n  /**\r\n   * Devuelve el tipo de dato de una propiedad en un ojeto\r\n   * @memberof uSchema\r\n   * @namespace getType\r\n   */\r\n  getType: {\r\n    /**\r\n     * Devuelve el tipo de dato de una propiedad de un objeto comun y corriente.\r\n     * @memberof uSchema.getType\r\n     * @param {*} value Valor de la propiedad del objeto a obtener su tipo.\r\n     * @returns {String} 'string', 'number', 'boolean', 'array' u 'object\r\n     */\r\n    obj: function (value) {\r\n      return Array.isArray(value) ? 'array' : typeof value;\r\n    },\r\n\r\n    /**\r\n     * Devuelve el tipo de dato de una propiedad de un objeto schema.\r\n     * @memberof uSchema.getType\r\n     * @param {*} value Valor de la propiedad del objeto a obtener su tipo.\r\n     * @returns {String} 'string', 'number', 'boolean', 'array' u 'object\r\n     */\r\n    schema: function (value) {\r\n      let retorno;\r\n      if (Array.isArray(value)) {\r\n        retorno = 'mixed';\r\n      } else {\r\n        if (uSchema.objLiteral(value)) {\r\n          retorno = value.hasOwnProperty('type') ? value.type : 'object';\r\n        } else {\r\n          const typeOfVal = typeof value;\r\n          if (typeOfVal === 'string') {\r\n            retorno = (uSchema.typesAccepted.indexOf(value) !== -1) ? value : typeOfVal;\r\n          } else {\r\n            retorno = typeOfVal\r\n          }\r\n        }\r\n      }\r\n      return retorno;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Registra incidentes dentro de un objeto, para que sirva de log o para el compilado.\r\n   * @memberof uSchema\r\n   * @param {Array|Object} target Lista y objeto destino.\r\n   * @param {Object|String} data Objeto que contendrá información de la propiedad faltante o tambien el string que será agregado al array.\r\n   * @param {String=} propName Nombre de la propiedad a crear dentro del objeto.\r\n   * @returns {Boolean} Registro exitoso: true. Intento de registro duplicado: false\r\n   */\r\n  reg: function (target, data, propName) {\r\n    let retorno = false;\r\n    if (propName) { // if exists this argument the target is a 'object'...\r\n      if (!target.hasOwnProperty(propName)) {\r\n        target[propName] = data;\r\n        retorno = true;\r\n      }\r\n    } else { // ... is not is a 'array'\r\n      target.push(data);\r\n      retorno = true;\r\n    }\r\n    return retorno;\r\n  },\r\n\r\n  /**\r\n   * Realiza un merge de los registros obtenidos por el tratado de un subschema.\r\n   * @memberof uSchema\r\n   * @param {Object} target Objeto destino en donde se realizará el merge de las propiedades.\r\n   * @param {Object} schema Objeto que contiene los registros (missings, errors, different)\r\n   * @param {String} parentProp Nombre de la propiedad padre de los registros\r\n   * @returns {Object}\r\n   */\r\n  mergeProps: function (target, schema, parentProp) {\r\n    // ERRORS\r\n    const itemReg = schema.errors;\r\n    if (itemReg.length) target.errors = target.errors.concat(itemReg);\r\n    \r\n    // MISSINGS\r\n    let missing;\r\n    ['required', 'optional'].forEach(function (item) {\r\n      missing = schema.missings[item];\r\n      if (missing.length) target.missings[item] = target.missings[item].concat(missing);\r\n    });\r\n    \r\n    // DIFFERENT AND COMPILED\r\n    let currentSchema;\r\n    ['different', 'compiled'].forEach(function (objName) {\r\n      currentSchema = schema[objName];\r\n      if (Object.keys(currentSchema).length) {\r\n        if (!target[objName].hasOwnProperty(parentProp)) target[objName][parentProp] = {};\r\n        target[objName][parentProp] = currentSchema;\r\n      };\r\n    });\r\n  }\r\n\r\n};","/**\r\n * Constructor del schema.\r\n * @constructor\r\n * @param {Object} obj Configuraciones iniciales del schema\r\n * @example\r\n * const mySchema = {\r\n *  name: 'string',\r\n *  age: 'number',\r\n *  email: {\r\n *    type: 'string',\r\n *    required: true\r\n *  }\r\n * }\r\n * const card = new Schema(schema);\r\n */\r\nfunction Schema (obj) {\r\n  this.schema = Object.assign({}, obj);\r\n  this.missings = {\r\n    required: [],\r\n    optional: []\r\n  };\r\n  this.different = {};\r\n  this.errors = [];\r\n  this.compiled = {};\r\n};","/**\r\n * Fusiona el objeto pasado con el schema creado\r\n * @param {Object} [obj] Objeto que se necesita compilar con el squema creado.\r\n * @returns {Object} El objeto fusionado con los valores por defecto en el esquema (si es que existen claro).\r\n */\r\nSchema.prototype.compile = function (obj) {\r\n  if (obj) this.validate(obj);\r\n  return this.missings.required.length ? false : this.compiled;\r\n};","/**\r\n * Valida si un objeto cumple con el schema designado.\r\n * @param {Object} response Objeto que comunmente se obtiene de un 'response' en una solicitud ajax\r\n * @returns {Boolean} Indica si el objeto pasado es válido o no con el schema.\r\n */\r\nSchema.prototype.validate = function (response) {\r\n  const schema = this.schema,\r\n        _this = this;\r\n  let retorno = true; // by default, is valid :)\r\n\r\n  Object.keys(schema).forEach(function (property) {\r\n    // Data form schema\r\n    const valPropSchema = schema[property];\r\n    const getTypeValSchema = uSchema.getType.schema(valPropSchema);\r\n\r\n    if (response.hasOwnProperty(property)) {\r\n      // Data from response\r\n      const valPropObj = response[property];\r\n      const getTypeValObj = uSchema.getType.obj(valPropObj);\r\n\r\n      switch (getTypeValSchema) {\r\n        case 'string':\r\n        case 'number':\r\n        case 'boolean':\r\n        case 'array':\r\n          if (getTypeValSchema !== getTypeValObj) {\r\n            if (valPropSchema.required) retorno = false;\r\n            uSchema.reg(_this.different, {\r\n              current: getTypeValObj,\r\n              expected: getTypeValSchema,\r\n              value: valPropObj\r\n            }, property);\r\n          } else {\r\n            uSchema.reg(_this.compiled, valPropObj, property)\r\n          }\r\n          break;\r\n        \r\n        case 'object':\r\n          if (getTypeValObj === 'object') {\r\n            if (valPropSchema.hasOwnProperty('properties')) {\r\n              const propertiesSchema = new Schema(valPropSchema.properties);\r\n              if (!propertiesSchema.validate(valPropObj)) retorno = false;\r\n              uSchema.mergeProps(_this, propertiesSchema, property);\r\n            } else {\r\n              uSchema.reg(_this.compiled, valPropObj, property);\r\n            }\r\n          } else {\r\n            if (valPropSchema.required) {\r\n              retorno = false;\r\n              uSchema.reg(_this.different, {\r\n                current: getTypeValObj,\r\n                expected: getTypeValSchema,\r\n                value: valPropObj\r\n              }, property);\r\n            }\r\n          }\r\n          break;\r\n        \r\n        case 'mixed':\r\n          const typesValid = valPropSchema.filter(function (type) {\r\n            return type === getTypeValObj;\r\n          });\r\n          // no body match with any types items.\r\n          if (!typesValid.length && valPropSchema.required) { \r\n            retorno = false;\r\n            uSchema.reg(_this.different, {\r\n              current: getTypeValObj,\r\n              expected: valPropSchema,\r\n              value: valPropObj\r\n            }, property);\r\n          } else {\r\n            uSchema.reg(_this.compiled, valPropObj, property)\r\n          }\r\n          break;\r\n\r\n        default:\r\n          console.log('format type dont accepted: ' + getTypeValSchema);\r\n          retorno = false;\r\n      }\r\n    } else {\r\n      let missing;\r\n      if (valPropSchema.required) {\r\n        retorno = false;\r\n        missing = 'required';\r\n      } else {\r\n        missing = 'optional';\r\n      }\r\n      uSchema.reg(_this.missings[missing], property);\r\n      if (valPropSchema.default) _this.compiled[property] = valPropSchema.default;\r\n    }\r\n  });\r\n\r\n  // Returning\r\n  return retorno;\r\n};"]}