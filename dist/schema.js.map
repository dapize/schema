{"version":3,"sources":["utils.js","constructor.js","compile.js","validate.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"schema.js","sourcesContent":["/**\r\n * Verifica si el objeto pasado es un objeto literal.\r\n * @param {Object} obj Objeto a verificar\r\n * @returns {Boolean}\r\n */\r\nconst objLiteral = function (obj) {\r\n  return Object.prototype.toString.call(obj).toLowerCase() === '[object object]'\r\n};\r\n\r\n/**\r\n * Lista de tipos de formato de variables\r\n */\r\nconst typesAccepted = ['string', 'number', 'boolean', 'array', 'object'];\r\n\r\n/**\r\n * Obtiene el tipo del valor pasado.\r\n * @param {Object|String} value El string y objecto que contiene el valor del objeto\r\n * @return {String}\r\n */\r\nconst getType = function (value) {\r\n  let retorno;\r\n  if (Array.isArray(value)) {\r\n    retorno = 'array';\r\n  } else {\r\n    if (objLiteral(value)) {\r\n      if (value.hasOwnProperty('type')) {\r\n        retorno = Array.isArray(value.type) ? 'mixed' : value.type\r\n      } else {\r\n        retorno = 'object';\r\n      }\r\n    } else {\r\n      const typeOfVal = typeof value;\r\n      if (typeOfVal === 'string') {\r\n        retorno = (typesAccepted.indexOf(value) === -1) ? typeOfVal : value;\r\n      } else {\r\n        retorno = typeOfVal\r\n      }\r\n\r\n    }\r\n  }\r\n  return retorno;\r\n};\r\n\r\n/**\r\n * Registra incidentes dentro de un objeto, para que sirva de log.\r\n * @param {Array|Object} target Lista y objeto destino.\r\n * @param {String} propName Nombre de la propiedad a crear dentro del objeto.\r\n * @param {Object} data Objeto que contendr치 informaci칩n de la propiedad faltante.\r\n * @returns {Boolean} Registro exitoso: true. Intento de registro duplicado: false\r\n */\r\nconst reg = function (target, propName, data) {\r\n  let retorno = false;\r\n  if (Array.isArray(target)) {\r\n    target.push(data);\r\n    retorno = true;\r\n  } else {\r\n    if (!target.hasOwnProperty(propName)) {\r\n      target[propName] = data;\r\n      retorno = true;\r\n    }\r\n  }\r\n  return retorno;\r\n};\r\n\r\n/**\r\n * Realiza un merge de los registros obtenidos de por el tratado de un subschema.\r\n * @param {Object} objTarget Objeto destino en donde se realizar치 el merge de las propiedades.\r\n * @param {Object} schema Objeto que contiene los registros (missings, errors, different)\r\n * @param {String} parentProp Nombre de la propiedad padre de los registros\r\n * @returns {Object}\r\n */\r\nconst mergeProps = function (objTarget, schema, parentProp) {\r\n  // ERRORS\r\n  const itemReg = schema.errors;\r\n  if (itemReg.length) objTarget.errors = objTarget.errors.concat(itemReg);\r\n  \r\n  // MISSINGS\r\n  let missing;\r\n  ['required', 'optional'].forEach(function (item) {\r\n    missing = schema.missings[item];\r\n    if (missing.length) objTarget.missings[item] = objTarget.missings[item].concat(missing);\r\n  });\r\n  \r\n  // DIFFERENT AND COMPILED\r\n  let currentSchema;\r\n  ['different', 'compiled'].forEach(function (objName) {\r\n    currentSchema = schema[objName];\r\n    if (Object.keys(currentSchema).length) {\r\n      if (!objTarget[objName].hasOwnProperty(parentProp)) objTarget[objName][parentProp] = {};\r\n      objTarget[objName][parentProp] = currentSchema;\r\n    };\r\n  });\r\n};","/**\r\n * Constructor del schema.\r\n * @constructor\r\n * @param {Object} obj Configuraciones iniciales del schema\r\n */\r\nfunction Schema (obj) {\r\n  this.schema = Object.assign({}, obj);\r\n  this.missings = {\r\n    required: [],\r\n    optional: []\r\n  };\r\n  this.different = {};\r\n  this.errors = [];\r\n  this.compiled = {};\r\n};","/**\r\n * Se obtiene el objeto compilado, el que a pasado por el schema\r\n * con las variables por defecto fusionadas.\r\n */\r\nSchema.prototype.compile = function () {\r\n  return this.missings.required.length ? false : this.compiled;\r\n};","/**\r\n * Valida si un objeto cumple con el schema designado.\r\n * @param {Object} response Objeto que comunmente se obtiene de un 'response' en una solicitud ajax\r\n * @returns {Boolean} Indica si el objeto pasado es v치lido o no con el schema.\r\n */\r\nSchema.prototype.validate = function (response) {\r\n  const schema = this.schema,\r\n        _this = this;\r\n  let retorno = true; // by default, is valid :)\r\n\r\n  Object.keys(schema).forEach(function (property) {\r\n    // Data form schema\r\n    const valPropSchema = schema[property];\r\n    const getTypeValSchema = getType(valPropSchema);\r\n\r\n    if (response.hasOwnProperty(property)) {\r\n      // Data from response\r\n      const valPropObj = response[property];\r\n      const getTypeValObj = getType(valPropObj);\r\n\r\n      switch (getTypeValSchema) {          \r\n        case 'string': // dont exists 'required', obiusly.\r\n          if (getTypeValObj !== 'string') {\r\n            reg(_this.different, property, {\r\n              current: getTypeValObj,\r\n              expected: 'string',\r\n              value: valPropObj\r\n            });\r\n          } else {\r\n            reg(_this.compiled, property, valPropObj)\r\n          }\r\n          break;\r\n\r\n        case 'array':\r\n          if (getTypeValSchema !== getTypeValObj) {\r\n            if (valPropSchema.required) retorno = false;\r\n            reg(_this.different, property, {\r\n              current: getTypeValObj,\r\n              expected: 'array',\r\n              value: valPropObj\r\n            });\r\n          } else {\r\n            reg(_this.compiled, property, valPropObj)\r\n          }\r\n          break;\r\n        \r\n        case 'object':\r\n          if (getTypeValObj === 'object') {\r\n            if (valPropSchema.hasOwnProperty('properties')) {\r\n              const propertiesSchema = new Schema(valPropSchema.properties);\r\n              if (!propertiesSchema.validate(valPropObj)) retorno = false;\r\n              mergeProps(_this, propertiesSchema, property);\r\n            } else {\r\n              reg(_this.compiled, property, valPropObj);\r\n            }\r\n          } else {\r\n            if (valPropSchema.required) {\r\n              retorno = false;\r\n              reg(_this.different, property,{\r\n                current: getTypeValObj,\r\n                expected: getTypeValSchema,\r\n                value: valPropObj\r\n              });\r\n            }\r\n          }\r\n          break;\r\n        \r\n        case 'mixed':\r\n          const typesList = valPropSchema.type;\r\n          const typesValid = typesList.filter(function (type) {\r\n            return type === getTypeValObj;\r\n          });\r\n          // no body match with any types items.\r\n          if (!typesValid.length && valPropSchema.required) { \r\n            retorno = false;\r\n            reg(_this.different, property, {\r\n              current: getTypeValObj,\r\n              expected: typesList,\r\n              value: valPropObj\r\n            });\r\n          } else {\r\n            reg(_this.compiled, property, valPropObj)\r\n          }\r\n          break;\r\n\r\n        default:\r\n          console.log('format type dont accepted: ' + getTypeValSchema);\r\n      }\r\n    } else {\r\n      let missing;\r\n      if (valPropSchema.required) {\r\n        retorno = false;\r\n        missing = 'required';\r\n      } else {\r\n        missing = 'optional';\r\n      }\r\n      reg(_this.missings[missing], null, property);\r\n      if (valPropSchema.default) _this.compiled[property] = valPropSchema.default;\r\n    }\r\n  });\r\n\r\n  // Returning\r\n  return retorno;\r\n};"]}