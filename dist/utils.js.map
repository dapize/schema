{"version":3,"names":[],"mappings":"","sources":["utils.js"],"sourcesContent":["/**\r\n * Utilidades varias\r\n * @namespace uSchema\r\n * @property {Array} typesAccepted Lista de tipos aceptados para ser procesados.\r\n */\r\nconst uSchema = {\r\n  /**\r\n   * Setea los valores por defecto del constructor\r\n   * @param {Function} _this Constructor\r\n   */\r\n  initValues: function (_this) {\r\n    _this.missings = {\r\n      required: [],\r\n      optional: []\r\n    };\r\n    _this.different = {};\r\n    _this.errors = [];\r\n    _this.compiled = {};\r\n  },\r\n\r\n  /**\r\n   * Verifica si lo pasado es un objeto literal o no\r\n   * @memberof uSchema\r\n   * @param {Object} obj Objeto a ser verificado\r\n   * @returns {Boolean}\r\n   * @example\r\n   * uSchema.objLiteral({});\r\n   * => true\r\n   * @example\r\n   * uSchema.objLiteral('obj');\r\n   * => false\r\n   */\r\n  objLiteral: function (obj) {\r\n    return Object.prototype.toString.call(obj).toLowerCase() === '[object object]'\r\n  },\r\n\r\n  typesAccepted: ['string', 'number', 'boolean', 'array', 'object'],\r\n\r\n  /**\r\n   * Devuelve el tipo de dato de una propiedad en un ojeto\r\n   * @memberof uSchema\r\n   * @namespace getType\r\n   */\r\n  getType: {\r\n    /**\r\n     * Devuelve el tipo de dato de una propiedad de un objeto comun y corriente.\r\n     * @memberof uSchema.getType\r\n     * @param {*} value Valor de la propiedad del objeto a obtener su tipo.\r\n     * @returns {String} 'string', 'number', 'boolean', 'array' u 'object\r\n     */\r\n    obj: function (value) {\r\n      return Array.isArray(value) ? 'array' : typeof value;\r\n    },\r\n\r\n    /**\r\n     * Devuelve el tipo de dato de una propiedad de un objeto schema.\r\n     * @memberof uSchema.getType\r\n     * @param {*} value Valor de la propiedad del objeto a obtener su tipo.\r\n     * @returns {String} 'string', 'number', 'boolean', 'array' u 'object\r\n     */\r\n    schema: function (value) {\r\n      let retorno;\r\n      if (Array.isArray(value)) {\r\n        retorno = 'mixed';\r\n      } else {\r\n        if (uSchema.objLiteral(value)) {\r\n          retorno = value.hasOwnProperty('type') ? this.schema(value.type) : 'object';\r\n        } else {\r\n          const typeOfVal = typeof value;\r\n          if (typeOfVal === 'string') {\r\n            retorno = (uSchema.typesAccepted.indexOf(value) !== -1) ? value : typeOfVal;\r\n          } else {\r\n            retorno = typeOfVal\r\n          }\r\n        }\r\n      }\r\n      return retorno;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Registra incidentes dentro de un objeto, para que sirva de log o para el compilado.\r\n   * @memberof uSchema\r\n   * @param {Array|Object} target Lista y objeto destino.\r\n   * @param {Object|String} data Objeto que contendr치 informaci칩n de la propiedad faltante o tambien el string que ser치 agregado al array.\r\n   * @param {String=} propName Nombre de la propiedad a crear dentro del objeto.\r\n   * @returns {Boolean} Registro exitoso: true. Intento de registro duplicado: false\r\n   */\r\n  reg: function (target, data, propName) {\r\n    let retorno = false;\r\n    if (propName) { // if exists this argument the target is a 'object'...\r\n      if (!target.hasOwnProperty(propName)) {\r\n        target[propName] = data;\r\n        retorno = true;\r\n      }\r\n    } else { // ... is not is a 'array'\r\n      target.push(data);\r\n      retorno = true;\r\n    }\r\n    return retorno;\r\n  },\r\n\r\n  /**\r\n   * Realiza un merge de los registros obtenidos por el tratado de un subschema.\r\n   * @memberof uSchema\r\n   * @param {Object} target Objeto destino en donde se realizar치 el merge de las propiedades.\r\n   * @param {Object} schema Objeto que contiene los registros (missings, errors, different)\r\n   * @param {String} parentProp Nombre de la propiedad padre de los registros\r\n   * @returns {Object}\r\n   */\r\n  mergeProps: function (target, schema, parentProp) {\r\n    // ERRORS\r\n    const itemReg = schema.errors;\r\n    if (itemReg.length) target.errors = target.errors.concat(itemReg);\r\n    \r\n    // MISSINGS\r\n    let missing;\r\n    ['required', 'optional'].forEach(function (item) {\r\n      missing = schema.missings[item];\r\n      if (missing.length) target.missings[item] = target.missings[item].concat(missing);\r\n    });\r\n    \r\n    // DIFFERENT AND COMPILED\r\n    let currentSchema;\r\n    ['different', 'compiled'].forEach(function (objName) {\r\n      currentSchema = schema[objName];\r\n      if (Object.keys(currentSchema).length) {\r\n        if (!target[objName].hasOwnProperty(parentProp)) target[objName][parentProp] = {};\r\n        target[objName][parentProp] = currentSchema;\r\n      };\r\n    });\r\n  }\r\n};"],"file":"utils.js"}